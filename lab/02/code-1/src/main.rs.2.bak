use std::env::var;
use std::fs::File;
use std::io::{Read, Write, stdin, stdout};
use finite_field::u131;

fn main() {
    let mut reader: Box<dyn Read> = if cfg!(feature = "online_judge") {
        Box::new(stdin())
    } else {
        let tc = var("TESTCASE").unwrap();
        Box::new(File::open(format!("samples/sample{tc}_in.bin")).unwrap())
    };
    let mut writer: Box<dyn Write> = if cfg!(feature = "online_judge") {
        Box::new(stdout())
    } else {
        let tc = var("TESTCASE").unwrap();
        Box::new(File::create(format!("samples/sample{tc}_out.bin")).unwrap())
    };

    let n = {
        let mut buffer = [0u8; 4];
        reader.read_exact(&mut buffer).unwrap();
        u32::from_le_bytes(buffer) as usize
    };

    for _ in 0..n {
        let op_type = {
            let mut buffer = [0u8; 1];
            reader.read_exact(&mut buffer).unwrap();
            buffer[0] as usize
        };

        let a = {
            let mut buffer = [0u8; 24];
            reader.read_exact(&mut buffer).unwrap();
            u131::from_le_bytes(buffer)
        };

        let b = {
            let mut buffer = [0u8; 24];
            reader.read_exact(&mut buffer).unwrap();
            u131::from_le_bytes(buffer)
        };

        let result = match op_type {
            0 => a + b,
            1 => a * b,
            2 => a.square(),
            3 => a.invert(),
            _ => panic!("Invalid operation type."),
        };
        writer.write_all(&result.into_le_bytes()).unwrap();
    }
}

mod finite_field {
    use core::ops::{Add, Mul, Div, Rem, Shl, ShrAssign};
    use core::cmp::{PartialOrd, Ordering};

    #[allow(non_camel_case_types)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct u131 {
        data: [u128; 4],
    }

    const N: usize = 131;
    const P: u131 = u131 {
        data: [
            0x00000000_00000000_00000000_00002007,
            0x00000000_00000000_00000000_00000008,
            0x00000000_00000000_00000000_00000000,
            0x00000000_00000000_00000000_00000000,
        ]
    };
    const Q: u131 = u131 {
        data: [
            0x00000000_00000000_00000000_00002005,
            0x00000000_00000000_00000000_00000008,
            0x00000000_00000000_00000000_00000000,
            0x00000000_00000000_00000000_00000000,
        ]
    };
    const ZERO: u131 = u131 {
        data: [0u128; 4],
    };
    const ONE: u131 = u131 {
        data: {
            let mut arr = [0u128; 4];
            arr[0] = 1;
            arr
        },
    };

    impl u131 {
        pub fn new() -> Self {
            Self {
                data: [0u128; 4],
            }
        }

        pub fn from_le_bytes(bytes: [u8; 24]) -> Self {
            let mut data = [0u128; 4];
            data[0] = u128::from_le_bytes(bytes[0..16].try_into().unwrap());
            data[1] = u64::from_le_bytes(bytes[16..24].try_into().unwrap()) as u128;
            Self {
                data,
            }
        }

        pub fn into_le_bytes(self) -> [u8; 24] {
            let mut bytes = [0u8; 24];
            bytes[0..16].copy_from_slice(&self.data[0].to_le_bytes());
            bytes[16..24].copy_from_slice(&(self.data[1] as u64).to_le_bytes());
            bytes
        }

        pub fn square(&self) -> Self {
            let mut res = Self::new();
            for i in 0..N {
                let bit = (self.data[i / 128] >> (i % 128)) & 1;
                res.data[(i * 2) / 128] ^= bit << ((i * 2) % 128);
            }
            res % P
        }

        pub fn invert(&self) -> Self {
            // let (_, inv) = Self::exgcd(*self, P);
            // inv
            Self::binexp(*self, Q)
        }

        // fn exgcd(a: Self, b: Self) -> (Self, Self) {
        //     let mut old_x = ONE;
        //     let mut x = ZERO;
        //     let mut old_y = ZERO;
        //     let mut y = ONE;
        //
        //     let mut a = a;
        //     let mut b = b;
        //
        //     while b != ZERO {
        //         let quotient = a / b;
        //
        //         let temp = b;
        //         b = a % b;
        //         a = temp;
        //
        //         let temp_x = x;
        //         x = old_x + (quotient * x);
        //         old_x = temp_x;
        //
        //         let temp_y = y;
        //         y = old_y + (quotient * y);
        //         old_y = temp_y;
        //     }
        //
        //     (old_x, old_y)
        // }

        fn binexp(mut base: Self, mut exp: Self) -> Self {
            let mut res = Self::new();
            res.data[0] = 1;

            while exp != ZERO {
                if exp.data[0] & 1 == 1 {
                    res = res * base % P;
                }
                base = base.square() % P;
                exp >>= 1;
            }
            res
        }
    }

    impl Add for u131 {
        type Output = Self;

        fn add(self, rhs: Self) -> Self::Output {
            Self {
                data: [
                    self.data[0] ^ rhs.data[0],
                    self.data[1] ^ rhs.data[1],
                    self.data[2] ^ rhs.data[2],
                    self.data[3] ^ rhs.data[3],
                ],
            }
        }
    }

    impl Mul for u131 {
        type Output = Self;

        fn mul(self, rhs: Self) -> Self::Output {
            let mut a = [0u8; N];
            (0..N).for_each(|i| a[i] = ((self.data[i / 128] >> (i % 128)) & 1) as u8);

            let mut b = [0u8; N];
            (0..N).for_each(|i| b[i] = ((rhs.data[i / 128] >> (i % 128)) & 1) as u8);

            let mut c = [0u8; N + N - 1];
            for i in 0..N {
                for j in 0..N {
                    c[i + j] ^= a[i] & b[j];
                }
            }

            let mut res = Self::new();
            (0..(N + N - 1)).rev().for_each(|i| res.data[i / 128] ^= (c[i] as u128) << (i % 128));

            res % P
        }
    }

    impl Div for u131 {
        type Output = Self;

        fn div(self, rhs: Self) -> Self::Output {
            let mut rem = self;
            let mut res = Self::new();
            for i in (0..N).rev() {
                if rem >= (rhs << i) {
                    res.data[i / 128] |= 1 << (i % 128);
                    rem = rem + (rhs << i);
                }
            }
            res
        }
    }

    impl Rem for u131 {
        type Output = Self;

        fn rem(self, rhs: Self) -> Self::Output {
            self + (self / rhs) * rhs
        }
    }

    impl Shl<usize> for u131 {
        type Output = Self;

        fn shl(self, rhs: usize) -> Self::Output {
            let mut res = Self::new();
            res.data[0] = self.data[0].wrapping_shl(rhs as u32);
            if rhs < 128 {
                for i in 1..4 {
                    res.data[i] = self.data[i].wrapping_shl(rhs as u32) | (self.data[i - 1].wrapping_shr(128 - (rhs as u32)));
                }
            } else {
                res.data[1] = self.data[0].wrapping_shl((rhs - 128) as u32);
                for i in 2..4 {
                    res.data[i] = self.data[i - 1].wrapping_shl((rhs - 128) as u32) | (self.data[i - 2].wrapping_shr(256 - (rhs as u32)));
                }
            }
            res
        }
    }

    impl ShrAssign<u32> for u131 {
        fn shr_assign(&mut self, rhs: u32) {
            if rhs < 128 {
                for i in 0..3 {
                    self.data[i] = self.data[i].wrapping_shr(rhs) | (self.data[i + 1].wrapping_shl(128 - rhs));
                }
                self.data[3] = self.data[3].wrapping_shr(rhs);
            } else {
                for i in 0..2 {
                    self.data[i] = self.data[i + 1].wrapping_shr(rhs - 128) | (self.data[i + 2].wrapping_shl(256 - rhs));
                }
                self.data[2] = self.data[3].wrapping_shr(rhs - 128);
                self.data[3] = 0;
            }
        }
    }

    impl PartialOrd for u131 {
        fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
            for i in (0..4).rev() {
                if self.data[i] < other.data[i] {
                    return Some(Ordering::Less);
                } else if self.data[i] > other.data[i] {
                    return Some(Ordering::Greater);
                }
            }
            Some(core::cmp::Ordering::Equal)
        }
    }
}
