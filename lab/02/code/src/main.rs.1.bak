use std::fmt;
use std::ops::{Add, Mul};

/// Represents an element in the finite field F₂₁₃₁ (GF(2¹³¹))
/// Each element is a polynomial with coefficients in {0, 1}
/// represented as a 131-bit binary number stored in a u128 and additional bits
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct F131 {
    // Store the 131-bit number as two parts: low 128 bits and high 3 bits
    low: u128,   // bits 0-127
    high: u8,    // bits 128-130 (only 3 bits used)
}

impl F131 {
    /// The irreducible polynomial: f = x¹³¹ + x¹³ + x² + x + 1
    /// In binary: 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001110
    const IRREDUCIBLE_POLY_LOW: u128 = 0b1110; // x¹³ + x² + x + 1
    const IRREDUCIBLE_POLY_HIGH: u8 = 0b100;   // x¹³¹ (bit 3 represents x¹³¹)

    /// Create a new F131 element from low and high parts
    pub fn new(low: u128, high: u8) -> Self {
        Self {
            low,
            high: high & 0b111, // Mask to ensure only 3 bits are used
        }
    }

    /// Create F131 element from a u128 (for numbers that fit in 128 bits)
    pub fn from_u128(value: u128) -> Self {
        Self::new(value, 0)
    }

    /// Create F131 element representing 0
    pub fn zero() -> Self {
        Self::new(0, 0)
    }

    /// Create F131 element representing 1
    pub fn one() -> Self {
        Self::new(1, 0)
    }

    /// Check if the element is zero
    pub fn is_zero(&self) -> bool {
        self.low == 0 && self.high == 0
    }

    /// Get the degree of the polynomial (highest bit position)
    pub fn degree(&self) -> Option<usize> {
        if self.high != 0 {
            for i in (0..3).rev() {
                if (self.high >> i) & 1 == 1 {
                    return Some(128 + i);
                }
            }
        }
        if self.low != 0 {
            for i in (0..128).rev() {
                if (self.low >> i) & 1 == 1 {
                    return Some(i);
                }
            }
        }
        None
    }

    /// Left shift by n positions
    fn shl(&self, n: usize) -> Self {
        if n == 0 {
            return *self;
        }
        if n >= 131 {
            return Self::zero();
        }

        if n < 128 {
            let new_low = self.low << n;
            let new_high = (self.high << n) | ((self.low >> (128 - n)) as u8);
            Self::new(new_low, new_high)
        } else {
            let shift = n - 128;
            Self::new(0, (self.low << shift) as u8)
        }
    }

    /// Right shift by n positions
    fn shr(&self, n: usize) -> Self {
        if n == 0 {
            return *self;
        }
        if n >= 131 {
            return Self::zero();
        }

        if n < 3 {
            let new_high = self.high >> n;
            let new_low = (self.low >> n) | ((self.high as u128) << (128 - n));
            Self::new(new_low, new_high)
        } else if n < 131 {
            let shift = n - 3;
            Self::new(((self.high as u128) >> shift), 0)
        } else {
            Self::zero()
        }
    }

    /// Reduce modulo the irreducible polynomial
    fn reduce(&self) -> Self {
        let mut result = *self;
        
        // Check if we need reduction (degree >= 131)
        while let Some(deg) = result.degree() {
            if deg < 131 {
                break;
            }
            
            // If x^deg is present, replace it with x^13 + x^2 + x + 1
            let reduction_shift = deg - 131;
            let reduction = Self::new(Self::IRREDUCIBLE_POLY_LOW, 0).shl(reduction_shift);
            result = result ^ reduction;
        }
        
        result
    }

    /// Square the element (a^2)
    pub fn square(&self) -> Self {
        // In GF(2^n), squaring is equivalent to multiplying
        (*self * *self).reduce()
    }

    /// Compute multiplicative inverse using Extended Euclidean Algorithm
    pub fn inverse(&self) -> Option<Self> {
        if self.is_zero() {
            return None;
        }

        // Extended Euclidean Algorithm for polynomials over GF(2)
        let mut old_r = Self::new(Self::IRREDUCIBLE_POLY_LOW, Self::IRREDUCIBLE_POLY_HIGH);
        let mut r = *self;
        let mut old_s = Self::zero();
        let mut s = Self::one();

        while !r.is_zero() {
            let quotient = Self::poly_div(&old_r, &r).0;
            let temp_r = r;
            r = old_r ^ (quotient * r);
            old_r = temp_r;

            let temp_s = s;
            s = old_s ^ (quotient * s);
            old_s = temp_s;
        }

        if old_r == Self::one() {
            Some(old_s.reduce())
        } else {
            None
        }
    }

    /// Polynomial division over GF(2)
    fn poly_div(dividend: &Self, divisor: &Self) -> (Self, Self) {
        if divisor.is_zero() {
            panic!("Division by zero polynomial");
        }

        let mut quotient = Self::zero();
        let mut remainder = *dividend;

        while !remainder.is_zero() {
            let remainder_deg = remainder.degree().unwrap_or(0);
            let divisor_deg = divisor.degree().unwrap_or(0);
            
            if remainder_deg < divisor_deg {
                break;
            }

            let shift = remainder_deg - divisor_deg;
            let term = Self::one().shl(shift);
            quotient = quotient ^ term;
            remainder = remainder ^ (divisor.shl(shift));
        }

        (quotient, remainder)
    }
}

// Addition in GF(2^n) is XOR
impl Add for F131 {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        Self::new(self.low ^ other.low, self.high ^ other.high)
    }
}

// Subtraction is the same as addition in GF(2^n)
impl std::ops::Sub for F131 {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        self + other
    }
}

// XOR operation (same as addition)
impl std::ops::BitXor for F131 {
    type Output = Self;

    fn bitxor(self, other: Self) -> Self {
        self + other
    }
}

// Multiplication in GF(2^n)
impl Mul for F131 {
    type Output = Self;

    fn mul(self, other: Self) -> Self {
        if self.is_zero() || other.is_zero() {
            return Self::zero();
        }

        let mut result = Self::zero();
        let mut multiplicand = self;

        // Multiply using shift-and-add
        for i in 0..131 {
            let bit = if i < 128 {
                (other.low >> i) & 1
            } else {
                ((other.high >> (i - 128)) & 1) as u128
            };

            if bit == 1 {
                result = result + multiplicand;
            }
            multiplicand = multiplicand.shl(1);
        }

        result.reduce()
    }
}

impl fmt::Display for F131 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "F131(low: 0x{:032x}, high: 0x{:02x})", self.low, self.high)
    }
}

impl fmt::Binary for F131 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:03b}{:0128b}", self.high, self.low)
    }
}

fn main() {
    // Example usage
    println!("F131 Finite Field Operations");
    println!("Irreducible polynomial: x^131 + x^13 + x^2 + x + 1");
    println!();

    // Create some test elements
    let a = F131::from_u128(0x123456789abcdef0123456789abcdef0);
    let b = F131::from_u128(0xfedcba0987654321fedcba0987654321);

    println!("a = {}", a);
    println!("b = {}", b);
    println!();

    // Addition
    let sum = a + b;
    println!("a + b = {}", sum);

    // Multiplication
    let product = a * b;
    println!("a * b = {}", product);

    // Squaring
    let a_squared = a.square();
    println!("a^2 = {}", a_squared);

    // Inverse
    match a.inverse() {
        Some(a_inv) => {
            println!("a^(-1) = {}", a_inv);
            // Verify: a * a^(-1) should equal 1
            let verification = a * a_inv;
            println!("Verification a * a^(-1) = {}", verification);
            println!("Is a * a^(-1) == 1? {}", verification == F131::one());
        }
        None => println!("a has no inverse (shouldn't happen for non-zero elements)"),
    }

    println!();
    println!("Testing with smaller numbers:");
    let x = F131::from_u128(5);  // x + 1
    let y = F131::from_u128(3);  // x + 1

    println!("x = {}", x);
    println!("y = {}", y);
    println!("x + y = {}", x + y);
    println!("x * y = {}", x * y);
    println!("x^2 = {}", x.square());
    
    if let Some(x_inv) = x.inverse() {
        println!("x^(-1) = {}", x_inv);
        println!("x * x^(-1) = {}", x * x_inv);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let a = F131::from_u128(5);
        let b = F131::from_u128(3);
        
        // Test addition (XOR)
        assert_eq!(a + b, F131::from_u128(6));
        
        // Test multiplication
        let product = a * b;
        assert!(!product.is_zero());
        
        // Test that a + a = 0 (characteristic 2)
        assert_eq!(a + a, F131::zero());
    }

    #[test]
    fn test_inverse() {
        let a = F131::from_u128(5);
        if let Some(a_inv) = a.inverse() {
            let product = a * a_inv;
            assert_eq!(product, F131::one());
        }
    }

    #[test]
    fn test_square() {
        let a = F131::from_u128(7);
        let a_squared = a.square();
        let a_times_a = a * a;
        assert_eq!(a_squared, a_times_a);
    }

    #[test]
    fn test_zero_inverse() {
        assert_eq!(F131::zero().inverse(), None);
    }
}

