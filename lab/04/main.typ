#import "@local/sysu-templates:0.2.0": report

#show: report.with(
  title: "实验四：SHA-256 的实现",
  subtitle: "现代密码学实验报告",
  student: (name: "元朗曦", id: "23336294"),
  institude: "计算机学院",
  major: "计算机科学与技术",
  class: "计八",
)

= 实验目的

通过实现 SHA-256 哈希函数，理解其工作原理和应用场景，掌握密码学哈希函数的设计思想和实现方法。

= 实验内容

用 Rust 实现 SHA-256。

= 实验原理

主要参考了 #link("https://sha256algorithm.com")[SHA-256 Algorithm Explained]。

= 实验步骤

我们将 SHA-256 的实现分为以下三部分：

+ 初始化：加载初始的 `h` 值和缓冲区。

+ 更新：将需要更新的数据分块处理，每块 512 bits，末尾不足一块的存入缓冲区。

+ 收尾：将缓冲区剩余的数据按规则填充并处理，得出最终的 hash 值。

完整代码如下：

#raw(block: true, lang: "rust", read("code-1/src/main.rs"))

= 实验结果

#figure(
  caption: [运行结果],
  image("assets/images/20251118-170647.png"),
)

#figure(
  caption: [提交记录],
  image("assets/images/20251118-170920.png"),
)

= 思考题

+ SHA-1 的初始常数是很有规律的 `0x67452301`，`0xEFCDAB89`，`0x98BADCFE`，`0x10325476`，`0xC3D2E1F0`，SHA-256 的初始常数和轮常数分别来自于前几个素数的平方根或立方根的小数部分。为什么要这么设计？

  答：这样设计可以避免被认为是带有后门的常数。

+ 有一类 hash 算法被称为“Non-cryptographic hash function”，例如 Java（OpenJDK）中 `hashCode` 的实现是非常简单的迭代计算 `h = 31 * h + x`，其他的此类算法包括 FNV、MurmurHash、xxHash 等。它们与 MD5、SHA-1、SHA-256 等 hash 算法的区别是什么？它们有哪些主要用途？为什么会比 SHA-256 等等更适合用于这些场景？

  答：Non-cryptographic hash function 主要用于数据结构（如哈希表）和数据校验等场景，强调速度和分布均匀性，而不是安全性。它们通常被用于需要快速计算哈希值但不需要防止碰撞攻击的场景。相比之下，SHA-256 等密码学哈希函数设计复杂，计算开销较大，更适合用于需要高安全性的场景，如数字签名和数据完整性验证。

+ 如果你需要设计一个用户系统，你也许知道数据库中不应该以明文存储用户的密码（遗憾的是，我国的知名计算机技术社区 CSDN 就犯过这样的错误），而应该存储密码的 hash。但是，在这种情况下直接使用 SHA-256 等等仍然是不推荐的。有哪些 hash 算法更适合用来处理密码？它们与 SHA-256 等等有什么区别？

  答：更适合处理密码的哈希算法包括 bcrypt、scrypt 和 Argon2 等。这些算法设计上考虑了抗 GPU 和 ASIC 攻击，通常具有较高的计算成本和内存需求，从而增加了暴力破解的难度。与 SHA-256 等通用哈希函数相比，这些密码哈希函数更注重安全性，能够有效防止彩虹表攻击和暴力破解。

+ 在比特币中，有一类节点的功能是将交易数据打包成区块附加到区块链上，而我们常说的“挖矿”，其基本原理就是不断变换区块中的 nonce 字段，使整个区块的 SHA-256（当成一个大整数）小于比特币网络当前规定的难度值。glminer 是一个由 EtherDream 编写的玩具版“挖矿”演示：给定 12 bytes 的数据 Q，要求找到另一串 4 bytes 的数据 A，使 Q+A 的 SHA-256 以 `00000000` 开头。尝试用你实现的 SHA-256 或各种标准库/第三方库来实现这一功能，并和 glminer 比较计算 SHA-256 的性能。查看#link("https://v2ex.com/t/347005")[在 V2EX 上的讨论]以及 glminer 的源代码，为什么会存在这样的性能差距？它是如何实现 SHA-256 计算的？

  答：glminer 通过使用高度优化的汇编代码和并行计算技术来实现 SHA-256 的计算，从而大幅提升了性能。相比之下，标准库或第三方库通常采用通用的实现方式，缺乏针对特定硬件的优化，因此在性能上存在显著差距。glminer 还可能利用 SIMD 指令集和多线程技术来进一步加速哈希计算过程。

= 实验总结

通过实现 SHA-256 哈希函数，理解了其工作原理和应用场景，掌握了密码学哈希函数的设计思想和实现方法。
